{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/EnriqueSalazar/Desktop/Dapp-Alexis/fcctoken/node_modules/@babel/runtime/helpers/asyncToGenerator\").default;\n\nconst SafeEventEmitter = require('@metamask/safe-event-emitter').default;\n\nconst createScaffoldMiddleware = require('eth-json-rpc-middleware/scaffold');\n\nconst {\n  createAsyncMiddleware\n} = require('json-rpc-engine');\n\nconst createFilterMiddleware = require('./index.js');\n\nconst {\n  unsafeRandomBytes,\n  incrementHexInt\n} = require('./hexUtils.js');\n\nconst getBlocksForRange = require('./getBlocksForRange.js');\n\nmodule.exports = createSubscriptionMiddleware;\n\nfunction createSubscriptionMiddleware({\n  blockTracker,\n  provider\n}) {\n  // state and utilities for handling subscriptions\n  const subscriptions = {};\n  const filterManager = createFilterMiddleware({\n    blockTracker,\n    provider\n  }); // internal flag\n\n  let isDestroyed = false; // create subscriptionManager api object\n\n  const events = new SafeEventEmitter();\n  const middleware = createScaffoldMiddleware({\n    eth_subscribe: createAsyncMiddleware(subscribe),\n    eth_unsubscribe: createAsyncMiddleware(unsubscribe)\n  });\n  middleware.destroy = destroy;\n  return {\n    events,\n    middleware\n  };\n\n  function subscribe(_x, _x2) {\n    return _subscribe.apply(this, arguments);\n  }\n\n  function _subscribe() {\n    _subscribe = _asyncToGenerator(function* (req, res) {\n      if (isDestroyed) throw new Error('SubscriptionManager - attempting to use after destroying');\n      const subscriptionType = req.params[0]; // subId is 16 byte hex string\n\n      const subId = unsafeRandomBytes(16); // create sub\n\n      let sub;\n\n      switch (subscriptionType) {\n        case 'newHeads':\n          sub = createSubNewHeads({\n            subId\n          });\n          break;\n\n        case 'logs':\n          const filterParams = req.params[1];\n          const filter = yield filterManager.newLogFilter(filterParams);\n          sub = createSubFromFilter({\n            subId,\n            filter\n          });\n          break;\n\n        default:\n          throw new Error(`SubscriptionManager - unsupported subscription type \"${subscriptionType}\"`);\n      }\n\n      subscriptions[subId] = sub;\n      res.result = subId;\n      return;\n\n      function createSubNewHeads({\n        subId\n      }) {\n        const sub = {\n          type: subscriptionType,\n          destroy: function () {\n            var _ref = _asyncToGenerator(function* () {\n              blockTracker.removeListener('sync', sub.update);\n            });\n\n            return function destroy() {\n              return _ref.apply(this, arguments);\n            };\n          }(),\n          update: function () {\n            var _ref2 = _asyncToGenerator(function* ({\n              oldBlock,\n              newBlock\n            }) {\n              // for newHeads\n              const toBlock = newBlock;\n              const fromBlock = incrementHexInt(oldBlock);\n              const rawBlocks = yield getBlocksForRange({\n                provider,\n                fromBlock,\n                toBlock\n              });\n              const results = rawBlocks.map(normalizeBlock);\n              results.forEach(value => {\n                _emitSubscriptionResult(subId, value);\n              });\n            });\n\n            return function update(_x5) {\n              return _ref2.apply(this, arguments);\n            };\n          }()\n        }; // check for subscription updates on new block\n\n        blockTracker.on('sync', sub.update);\n        return sub;\n      }\n\n      function createSubFromFilter({\n        subId,\n        filter\n      }) {\n        filter.on('update', result => _emitSubscriptionResult(subId, result));\n        const sub = {\n          type: subscriptionType,\n          destroy: function () {\n            var _ref3 = _asyncToGenerator(function* () {\n              return yield filterManager.uninstallFilter(filter.idHex);\n            });\n\n            return function destroy() {\n              return _ref3.apply(this, arguments);\n            };\n          }()\n        };\n        return sub;\n      }\n    });\n    return _subscribe.apply(this, arguments);\n  }\n\n  function unsubscribe(_x3, _x4) {\n    return _unsubscribe.apply(this, arguments);\n  }\n\n  function _unsubscribe() {\n    _unsubscribe = _asyncToGenerator(function* (req, res) {\n      if (isDestroyed) throw new Error('SubscriptionManager - attempting to use after destroying');\n      const id = req.params[0];\n      const subscription = subscriptions[id]; // if missing, return \"false\" to indicate it was not removed\n\n      if (!subscription) {\n        res.result = false;\n        return;\n      } // cleanup subscription\n\n\n      delete subscriptions[id];\n      yield subscription.destroy();\n      res.result = true;\n    });\n    return _unsubscribe.apply(this, arguments);\n  }\n\n  function _emitSubscriptionResult(filterIdHex, value) {\n    events.emit('notification', {\n      jsonrpc: '2.0',\n      method: 'eth_subscription',\n      params: {\n        subscription: filterIdHex,\n        result: value\n      }\n    });\n  }\n\n  function destroy() {\n    events.removeAllListeners();\n\n    for (const id in subscriptions) {\n      subscriptions[id].destroy();\n      delete subscriptions[id];\n    }\n\n    isDestroyed = true;\n  }\n}\n\nfunction normalizeBlock(block) {\n  return {\n    hash: block.hash,\n    parentHash: block.parentHash,\n    sha3Uncles: block.sha3Uncles,\n    miner: block.miner,\n    stateRoot: block.stateRoot,\n    transactionsRoot: block.transactionsRoot,\n    receiptsRoot: block.receiptsRoot,\n    logsBloom: block.logsBloom,\n    difficulty: block.difficulty,\n    number: block.number,\n    gasLimit: block.gasLimit,\n    gasUsed: block.gasUsed,\n    nonce: block.nonce,\n    mixHash: block.mixHash,\n    timestamp: block.timestamp,\n    extraData: block.extraData\n  };\n}","map":{"version":3,"sources":["C:/Users/EnriqueSalazar/Desktop/Dapp-Alexis/fcctoken/node_modules/eth-json-rpc-filters/subscriptionManager.js"],"names":["SafeEventEmitter","require","default","createScaffoldMiddleware","createAsyncMiddleware","createFilterMiddleware","unsafeRandomBytes","incrementHexInt","getBlocksForRange","module","exports","createSubscriptionMiddleware","blockTracker","provider","subscriptions","filterManager","isDestroyed","events","middleware","eth_subscribe","subscribe","eth_unsubscribe","unsubscribe","destroy","req","res","Error","subscriptionType","params","subId","sub","createSubNewHeads","filterParams","filter","newLogFilter","createSubFromFilter","result","type","removeListener","update","oldBlock","newBlock","toBlock","fromBlock","rawBlocks","results","map","normalizeBlock","forEach","value","_emitSubscriptionResult","on","uninstallFilter","idHex","id","subscription","filterIdHex","emit","jsonrpc","method","removeAllListeners","block","hash","parentHash","sha3Uncles","miner","stateRoot","transactionsRoot","receiptsRoot","logsBloom","difficulty","number","gasLimit","gasUsed","nonce","mixHash","timestamp","extraData"],"mappings":"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","sourcesContent":["const SafeEventEmitter = require('@metamask/safe-event-emitter').default\nconst createScaffoldMiddleware = require('eth-json-rpc-middleware/scaffold')\nconst { createAsyncMiddleware } = require('json-rpc-engine')\nconst createFilterMiddleware = require('./index.js')\nconst { unsafeRandomBytes, incrementHexInt } = require('./hexUtils.js')\nconst getBlocksForRange = require('./getBlocksForRange.js')\n\nmodule.exports = createSubscriptionMiddleware\n\n\nfunction createSubscriptionMiddleware({ blockTracker, provider }) {\n  // state and utilities for handling subscriptions\n  const subscriptions = {}\n  const filterManager = createFilterMiddleware({ blockTracker, provider })\n\n  // internal flag\n  let isDestroyed = false\n\n  // create subscriptionManager api object\n  const events = new SafeEventEmitter()\n  const middleware = createScaffoldMiddleware({\n    eth_subscribe: createAsyncMiddleware(subscribe),\n    eth_unsubscribe: createAsyncMiddleware(unsubscribe),\n  })\n  middleware.destroy = destroy\n  return { events, middleware }\n\n  async function subscribe(req, res) {\n\n    if (isDestroyed) throw new Error(\n      'SubscriptionManager - attempting to use after destroying'\n    )\n\n    const subscriptionType = req.params[0]\n    // subId is 16 byte hex string\n    const subId = unsafeRandomBytes(16)\n\n    // create sub\n    let sub\n    switch (subscriptionType) {\n      case 'newHeads':\n        sub = createSubNewHeads({ subId })\n        break\n      case 'logs':\n        const filterParams = req.params[1]\n        const filter = await filterManager.newLogFilter(filterParams)\n        sub = createSubFromFilter({ subId, filter })\n        break\n      default:\n        throw new Error(`SubscriptionManager - unsupported subscription type \"${subscriptionType}\"`)\n\n    }\n    subscriptions[subId] = sub\n\n    res.result = subId\n    return\n\n    function createSubNewHeads({ subId }) {\n      const sub = {\n        type: subscriptionType,\n        destroy: async () => {\n          blockTracker.removeListener('sync', sub.update)\n        },\n        update: async ({ oldBlock, newBlock }) => {\n          // for newHeads\n          const toBlock = newBlock\n          const fromBlock = incrementHexInt(oldBlock)\n          const rawBlocks = await getBlocksForRange({ provider, fromBlock, toBlock })\n          const results = rawBlocks.map(normalizeBlock)\n          results.forEach((value) => {\n            _emitSubscriptionResult(subId, value)\n          })\n        }\n      }\n      // check for subscription updates on new block\n      blockTracker.on('sync', sub.update)\n      return sub\n    }\n\n    function createSubFromFilter({ subId, filter }){\n      filter.on('update', result => _emitSubscriptionResult(subId, result))\n      const sub = {\n        type: subscriptionType,\n        destroy: async () => {\n          return await filterManager.uninstallFilter(filter.idHex)\n        },\n      }\n      return sub\n    }\n  }\n\n  async function unsubscribe(req, res) {\n\n    if (isDestroyed) throw new Error(\n      'SubscriptionManager - attempting to use after destroying'\n    )\n\n    const id = req.params[0]\n    const subscription = subscriptions[id]\n    // if missing, return \"false\" to indicate it was not removed\n    if (!subscription) {\n      res.result = false\n      return\n    }\n    // cleanup subscription\n    delete subscriptions[id]\n    await subscription.destroy()\n    res.result = true\n  }\n\n  function _emitSubscriptionResult(filterIdHex, value) {\n    events.emit('notification', {\n      jsonrpc: '2.0',\n      method: 'eth_subscription',\n      params: {\n        subscription: filterIdHex,\n        result: value,\n      },\n    })\n  }\n\n  function destroy () {\n    events.removeAllListeners()\n    for (const id in subscriptions) {\n      subscriptions[id].destroy()\n      delete subscriptions[id]\n    }\n    isDestroyed = true\n  }\n}\n\nfunction normalizeBlock(block) {\n  return {\n    hash: block.hash,\n    parentHash: block.parentHash,\n    sha3Uncles: block.sha3Uncles,\n    miner: block.miner,\n    stateRoot: block.stateRoot,\n    transactionsRoot: block.transactionsRoot,\n    receiptsRoot: block.receiptsRoot,\n    logsBloom: block.logsBloom,\n    difficulty: block.difficulty,\n    number: block.number,\n    gasLimit: block.gasLimit,\n    gasUsed: block.gasUsed,\n    nonce: block.nonce,\n    mixHash: block.mixHash,\n    timestamp: block.timestamp,\n    extraData: block.extraData,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}